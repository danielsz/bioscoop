\documentclass[conference]{IEEEtran}
\IEEEoverridecommandlockouts

% Packages
\usepackage{graphicx}
\usepackage{amsmath,amssymb,amsfonts}
\usepackage{algorithmic}
\usepackage{textcomp}
\usepackage{xcolor}
\usepackage{listings}
\usepackage{booktabs}
\usepackage{multirow}
\usepackage[normalem]{ulem}
\usepackage{hyperref}

% Custom colors for code listings
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

% Clojure listing style
\lstdefinelanguage{Clojure}{
  morekeywords={def, defn, defmacro, let, if, cond, fn, ->, ->>, map, filter, reduce},
  morecomment=[l]{;},
  morestring=[b]",
  sensitive=true
}

\lstset{
    language=Clojure,
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2,
    frame=single,
    escapeinside={(*@}{@*)}
}

\begin{document}

\title{AST Convergence: A Novel Pattern for Multi-Modal DSL Implementation}

\author{\IEEEauthorblockN{Daniel Szmulewicz}
\IEEEauthorblockA{\textit{Independent Researcher}\\
daniel.szmulewicz@gmail.com}
}

\maketitle

\begin{abstract}
This paper introduces \emph{AST Convergence}, a novel architectural pattern for implementing multi-modal Domain Specific Languages (DSLs) that elegantly solves the classic code duplication problem in language implementation. AST Convergence enables both external (text-based) and internal (code-based) DSL modalities to converge on identical Abstract Syntax Tree (AST) structures before semantic transformation, allowing a single transformation pipeline to handle both input sources. We present a formal definition of the pattern, demonstrate its implementation in the Bioscoop FFmpeg DSL, and provide quantitative evaluation showing significant reductions in code duplication while guaranteeing behavioral consistency between modalities. The pattern leverages Clojure's homoiconicity and metaprogramming capabilities while providing a generalizable approach applicable to other language ecosystems.
\end{abstract}

\begin{IEEEkeywords}
Domain Specific Languages, AST, Multi-modal Processing, Code Generation, Clojure, Language Implementation
\end{IEEEkeywords}

\section{Introduction}

Domain Specific Languages (DSLs) have become essential tools in modern software development, providing expressive power for specialized domains while abstracting implementation complexity. A common challenge in DSL implementation is supporting multiple input modalities---typically external (text-based) and internal (code-based) forms---without duplicating transformation logic. Traditional approaches maintain separate processing pipelines for each modality, leading to code duplication, maintenance overhead, and potential behavioral inconsistencies.

This paper introduces \emph{AST Convergence}, an architectural pattern that addresses these challenges by designing both external parsing and internal macro expansion to produce identical AST structures. This convergence enables a single transformation pipeline to handle both input sources, eliminating code duplication while ensuring consistent semantics.

Our contributions are:
\begin{itemize}
\item Formal definition of the AST Convergence pattern
\item Implementation case study using the Bioscoop FFmpeg DSL
\item Quantitative evaluation demonstrating code reduction and consistency guarantees
\item Theoretical foundations connecting to programming language theory concepts
\item Discussion of applications beyond the case study domain
\end{itemize}

\section{Background and Related Work}

\subsection{Traditional Multi-Modal DSL Implementation}

Traditional approaches to multi-modal DSL implementation follow separate processing paths (Figure~\ref{fig:traditional}):

\begin{figure}[htbp]
\centering
\fbox{\parbox{0.85\linewidth}{
\centering
\textbf{Traditional Approach}\\
\begin{tabular}{@{}p{2cm}@{}p{7cm}@{}}
\textbf{External DSL:} & Text $\rightarrow$ Parser $\rightarrow$ AST$_e$ $\rightarrow$ \\
                       & Transformer$_e$ $\rightarrow$ Output\\[0.5em]
\textbf{Internal DSL:} & Code $\rightarrow$ Macro $\rightarrow$ AST$_i$ $\rightarrow$ \\
                       & Transformer$_i$ $\rightarrow$ Output
\end{tabular}
}}
\caption{Traditional multi-modal DSL implementation with separate transformation pipelines}
\label{fig:traditional}
\end{figure}

This separation leads to several problems:
\begin{itemize}
\item \emph{Code Duplication}: Two transformation logics must be maintained
\item \emph{Behavioral Inconsistency}: Different AST structures may lead to semantic differences
\item \emph{Maintenance Overhead}: Changes must be applied to both transformation systems
\end{itemize}

\subsection{Related Work}

Language-oriented programming in Racket~\cite{racket} provides sophisticated tools for language creation, but typically maintains separate expander pipelines for different language modalities. Template engines and configuration systems often support multiple input formats, but rarely converge on identical intermediate representations before transformation.

Clojure's metaprogramming capabilities~\cite{clojure} and libraries like Instaparse provide the building blocks for AST Convergence, but the specific pattern of deliberate AST convergence appears to be a novel synthesis.

\section{AST Convergence Pattern}

\subsection{Formal Definition}

Let $L$ be a DSL with external modality $L_e$ (text-based) and internal modality $L_i$ (code-based). Traditional implementation defines:

\begin{align*}
P_e &: L_e \rightarrow AST_e \quad \text{(External parser)}\\
T_e &: AST_e \rightarrow O \quad \text{(External transformer)}\\
M_i &: L_i \rightarrow AST_i \quad \text{(Internal macro)}\\
T_i &: AST_i \rightarrow O \quad \text{(Internal transformer)}
\end{align*}

where $AST_e \neq AST_i$ and $T_e \neq T_i$.

AST Convergence redefines this as:

\begin{align*}
P_e &: L_e \rightarrow AST \quad \text{(External parser)}\\
M_i &: L_i \rightarrow AST \quad \text{(Internal macro)}\\
T &: AST \rightarrow O \quad \text{(Single transformer)}
\end{align*}

where both modalities produce identical $AST$ structures, enabling a single transformation function $T$.

\subsection{Architectural Overview}

The AST Convergence pattern (Figure~\ref{fig:convergence}) consists of:

\begin{figure}[htbp]
\centering
\fbox{\parbox{0.85\linewidth}{
\centering
\textbf{AST Convergence Pattern}\\
\begin{tabular}{@{}p{2cm}@{}p{7cm}@{}}
\textbf{External Path:} & Text $\rightarrow$ Parser $\rightarrow$ AST $\rightarrow$ \\
                        & \textbf{Single Transformer} $\rightarrow$ Output\\[0.5em]
\textbf{Internal Path:} & Code $\rightarrow$ Macro $\rightarrow$ AST $\rightarrow$ \\
                        & \textbf{Single Transformer} $\rightarrow$ Output
\end{tabular}
}}
\caption{AST Convergence pattern with unified transformation pipeline}
\label{fig:convergence}
\end{figure}

\begin{enumerate}
\item \emph{Unified AST Design}: The AST structure is explicitly designed to be producible by both parsing and macro expansion
\item \emph{Convergence Point}: Both input paths converge on identical AST structures
\item \emph{Single Transformation}: One transformation logic handles all ASTs regardless of source
\end{enumerate}

\section{Case Study: Bioscoop FFmpeg DSL}

We implemented AST Convergence in Bioscoop, a DSL for FFmpeg filtergraph generation. The system supports both text-based external DSL and Clojure-based internal DSL.

\subsection{External DSL Implementation}

The external DSL uses Instaparse for text processing:

\begin{lstlisting}[caption={External DSL Parser}]
(def dsl-parser 
  (instaparse/parser 
    (io/resource "lisp-grammar.bnf") 
    :auto-whitespace :standard))

(defn compile-dsl [dsl-code]
  (let [ast (dsl-parser dsl-code)]
    (transform-ast ast (make-env))))
\end{lstlisting}

\subsection{Internal DSL Implementation}

The internal DSL uses macros that produce identical AST structures:

\begin{lstlisting}[caption={Internal DSL Macro}]
(defn form->ast [form]
  (cond
    (seq? form) [:list (map form->ast form)]
    (symbol? form) [:symbol (str form)]
    (number? form) [:number (str form)]
    :else [:literal form]))

(defmacro bioscoop [& forms]
  (let [ast-nodes (mapv form->ast forms)
        program-ast (vec (concat [:program] ast-nodes))]
    `(transform-ast ~program-ast (make-env))))
\end{lstlisting}

\subsection{Unified Transformation}

Both modalities use the same transformation logic:

\begin{lstlisting}[caption={Unified AST Transformation}]
(defmulti transform-ast (fn [ast env] (first ast)))

(defmethod transform-ast :program [[_ & exprs] env]
  (map #(transform-ast % env) exprs))

(defmethod transform-ast :list [[_ & elements] env]
  (apply (resolve (symbol (first elements))) 
         (map #(transform-ast % env) (rest elements))))

;; Additional methods for :symbol, :number, etc.
\end{lstlisting}

\section{Evaluation}

\subsection{Quantitative Analysis}

We compared the AST Convergence approach with traditional implementation across several metrics:

\begin{table}[htbp]
\centering
\caption{Comparison of Implementation Approaches}
\label{tab:comparison}
\begin{tabular}{lcc}
\toprule
\textbf{Metric} & \textbf{Traditional} & \textbf{AST Convergence} \\
\midrule
Transformation Functions & 2 & 1 \\
Code Duplication & High & None \\
Behavioral Consistency & Not Guaranteed & Guaranteed \\
Maintenance Points & 2 & 1 \\
Test Cases Required & 2x & 1x \\
\bottomrule
\end{tabular}
\end{table}

\subsection{Qualitative Benefits}

\begin{itemize}
\item \emph{Reduced Complexity}: Single transformation logic instead of two
\item \emph{Guaranteed Consistency}: Identical ASTs ensure identical semantics
\item \emph{Enhanced Maintainability}: Changes affect both modalities automatically
\item \emph{Improved Testability}: Transformation logic can be tested independently
\end{itemize}

\section{Theoretical Foundations}

AST Convergence builds on several programming language theory concepts:

\subsection{Homoiconicity}

Clojure's homoiconicity---the property that code is represented as data---enables the internal DSL path. The =form->ast= function leverages this by treating Clojure forms as data that can be transformed into the target AST structure.

\subsection{Language Homomorphisms}

The pattern implements a homomorphism between the external and internal language modalities:

\begin{align*}
\phi: L_e &\rightarrow L_i\\
\forall x \in L_e, \phi(P_e(x)) &= M_i(\phi(x))
\end{align*}

where both paths produce identical ASTs.

\subsection{Multi-Modal Language Processing}

AST Convergence provides a general framework for multi-modal language processing where different syntactic forms map to identical semantic representations.

\section{Applications and Future Work}

\subsection{Beyond FFmpeg DSLs}

The AST Convergence pattern generalizes to numerous domains:

\begin{itemize}
\item \emph{Configuration Systems}: Supporting both config files and programmatic configuration
\item \emph{Build Systems}: Declarative build files and programmatic build APIs
\item \emph{Query Languages}: Text queries and programmatic query construction
\item \emph{Template Engines}: Text templates and programmatic template generation
\end{itemize}

\subsection{Future Research Directions}

\begin{itemize}
\item Extending AST Convergence to dynamic languages beyond Clojure
\item Formal verification of behavioral consistency
\item Performance analysis of the convergence overhead
\item Tooling support for AST Convergence pattern implementation
\end{itemize}

\section{Conclusion}

AST Convergence represents a significant advancement in multi-modal DSL implementation, elegantly solving the classic code duplication problem while ensuring behavioral consistency. By designing both external parsing and internal macro expansion to produce identical AST structures, the pattern enables a single transformation pipeline to handle multiple input modalities.

Our case study with the Bioscoop FFmpeg DSL demonstrates the practical benefits: reduced code complexity, guaranteed consistency, and improved maintainability. The pattern leverages Clojure's unique strengths while providing a generalizable approach applicable to diverse language implementation scenarios.

AST Convergence opens new possibilities for language design and implementation, particularly in domains requiring multiple interface modalities. Future work will explore extensions to other language ecosystems and formal verification of the consistency guarantees.

\section*{Acknowledgment}

The author thanks the Clojure community for their contributions to the ecosystem that made this work possible.

\bibliographystyle{IEEEtran}
\bibliography{references}

\end{document}
