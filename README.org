* Bioscoop

#+begin_quote
The acts of the mind, wherein it exerts its power over simple ideas,
are chiefly these three:

1. Combining several simple ideas into one compound one, and thus all complex ideas are made.
2. The second is bringing two ideas, whether simple or complex,
   together, and setting them by one another so as to take a view of
   them at once, without uniting them into one, by which it gets all its ideas of
relations.
3. The third is separating them from all other ideas that accompany
   them in their real existence: this is called abstraction, and thus all its general ideas are made.
â€”John Locke, An Essay Concerning Human Understanding (1690)
#+end_quote

* Motivation

Historically, video editing has progressed from destructive techniques
(cutting the negative) to non-destructive ones (non-linear
editing). In both cases, the creative process is manual
(mouse-based). A different approach, often overlooked, is
programmatic, whereby the editor spells out the edits he wants to
apply, and those instructions are then further processed by the
framework.


no less promising,

Programming videos in a different exercise, 

model 

Non-linear editing is the 

Bioscoop puts programmability in the center of the creative process in tis a  to program videos
(instead of non-linear editing). It is a Domain Specific Language
(DSL) builds upon that transforms how
developers work with FFmpeg filtergraphs. By replacing FFmpeg's
notoriously complex and error-prone string-based syntax with a
structured, data-first approach, Bioscoop reinterprets FFMpeg's
filtergaph as a first-class composable unit. This in turn enables
(dramatic) improvements in developer productivity, code
maintainability, and system reliability.

* Key Improvements Over Native FFmpeg Syntax

** *Structural Integrity Through Data-First Design*

*Problem*: FFmpeg filtergraphs are fragile string concatenations where a
single misplaced comma or bracket can cause cryptic failures.

*Solution*: Bioscoop represents filtergraphs as immutable data structures:

#+begin_src clojure
;; Instead of: "scale=1920:1080,overlay"
(make-filterchain [(scale {:width 1920 :height 1080})
                   (overlay)])
#+end_src

Users conveniently write:

#+begin_src clojure
(defgraph my-filterchain (chain (scale {:width 1920 :height 1080})
                                (overlay)))
#+end_src

*Benefits*:
- *Type safety*: Parameters are validated before execution
- *Immutability*: Filtergraphs can be safely composed and transformed
- *Structural validation*: Invalid connections are caught at compile time

*** *Composable Architecture*

*Problem*: FFmpeg lacks native composition mechanisms, forcing
developers to manually manage complex filtergraph concatenation.

*Solution*: Built-in composition protocol:

#+begin_src clojure
;; Seamless composition
(compose scale-graph overlay-graph crop-graph)
#+end_src

*Benefits*:
- *Modular design*: Complex pipelines built from simple components
- *Reusability*: Filtergraphs become first-class composable units
- *Testability*: Individual components can be tested in isolation


*** *Decoupled Label Management*

*Problem*: FFmpeg's label management is tightly coupled with
filtergraphs. Users have to manually label filtergraphs, it is
error-prone and difficult to debug.

*Solution*: Decoupling of labels and filtergraphs.

This is achieved internally by implementing labels as metadata on filters:

#+begin_src clojure
(-> (make-filter 'scale {:width 1920 :height 1080})
    (with-labels ["in"] ["out"]))
#+end_src

Bioscoop espouses the format of FFmpeg to label filterchains, input
labels at the left of a filterchain, output labels at the right. 

#+begin_src clojure
;; This is equivalent: "[in]scale=1920:1080[scaled]"
(bioscoop [["in"] (scale {:width 1920 :height 1080}) ["out"]])
#+end_src

However, because filtergraphs are first-class, we can now write:

#+begin_src clojure
(defgraph scaled (scale {:with 1920 :height 1080})) ;; first-class filtergraph, independent of labels

(bioscoop [["in"] scaled ["out"]]) ;; attach labels to filtergraph
#+end_src

*Benefits*:
- *Decoupling:* Labels and filtergraphs can be handled separately
- *Automatic label generation*: No more manual label tracking
- *Label validation*: Prevents duplicate or missing labels
- *Metadata preservation*: Labels persist through transformations

*** *Bidirectional Transformation*

*Problem*: FFmpeg filtergraphs are one-way - once created as strings,
they can't be easily analyzed or modified.

*Solution*: Round-trip transformation capabilities:

#+begin_src clojure
;; Parse FFmpeg string to data structure
(def parsed (ffmpeg/parse "scale=1920:1080,overlay"))

;; Modify the data structure
(def modified (update-in parsed [:chains 0 :filters] conj (crop {:width 800})))

;; Render back to FFmpeg string
(to-ffmpeg modified) ; => "scale=1920:1080,overlay,crop=width=800"
#+end_src

*Benefits*:
- *Analysis*: Programmatically inspect and analyze existing filtergraphs
- *Transformation*: Modify filtergraphs without string manipulation
- *Migration*: Update old filtergraph syntax to new patterns

*** Parameterization

In Ffmpeg, filters take parameters. This is what makes them flexible,
expressive and powerful. Those parameters need to be hard-coded in the
filtergraph expression. Not so with bioscoop.


*** *Advanced Error Handling*

*Problem*: FFmpeg provides cryptic error messages that are difficult to
trace back to specific filtergraph issues.

*Solution*: Structured error reporting with context:

#+begin_src clojure
(defprotocol ErrorHandling
  (accumulate-error [env value error-type]))
  
;; Detailed error information instead of "Invalid filter specification"
#+end_src

*Benefits*:
- *Precise error localization*: Know exactly which filter failed
- *Contextual information*: Error messages include surrounding filter context
- *Validation before execution*: Catch errors before invoking FFmpeg

*** *Spec-Driven Validation*

*Problem*: FFmpeg parameters are validated at runtime, often with
unclear error messages.

*Solution*: Pre-execution validation using Clojure spec:

#+begin_src clojure
(s/def ::width (s/and int? pos?))
(s/def ::height (s/and int? pos?))
(s/def ::scale-args (s/keys :req-un [::width ::height]))

;; Validation happens before FFmpeg execution
#+end_src

*Benefits*:
- *Early error detection*: Catch invalid parameters before FFmpeg runs
- *Clear error messages*: Know exactly which parameter failed validation
- *Documentation*: Specs serve as living documentation for filter parameters


** Motivation 

Yes, FFmpeg is everywhere and it is amazing, but it is mainly used for
post-processing. Bioscoop is an attempt to unleash the power of FFmpeg
in the creative process. It offers an alternative to Non-Linear
editing of videos in favor of a programmatic approach.

FFmpeg offers a wealth of filters that can be
terseness, information density


FFmpeg has asserted its dominance in the post-processing phase of
video 
Unleash the power of FFmpeg in the creative process, beyond its
dominance in the post-processing 


[file:resources/itsallaboutfilters.jpeg]


#+HTML: <img src="resources/itsallaboutfilters.jpeg" width="867" height="499"/>

It is a language-focused solution to the information density problem
of FFmpeg's filtergraph syntax.
It's not only that they are dense and terse, they lack
abstractions. They do not allow for composition, which is a key
principle when designing a system.


#+HTML: <video controls width="400"><source src="resources/output.mp4" type="video/mp4/></video>

#+begin_src clojure

#+end_src

Told in the words of communties:

- Clojurians: a dsl that compiles Lisp forms to FFmpeg's filtergraph
- PLT: A context-free grammar describing a simple Lisp language -> AST transformation into data structues
-   
