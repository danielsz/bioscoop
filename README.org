
[[file:resources/logo.svg]]

By replacing FFmpeg's notoriously complex and error-prone string-based
syntax with a structured, data-first approach, Bioscoop reifies
FFMpeg's filtergaph into a first-class, composable unit. This in turn
enables (dramatic) improvements in creative freedom, programmability,
maintainability and reliability.

* Creative coding with video

+ [[https://danielsz.github.io/bioscoop/][Documentation]]
+ [[#gallery][Gallery]]

#+HTML: <img src="gallery/itsallaboutfilters.jpeg" width="400"/>
  
** Key Improvements Over Native FFmpeg Syntax

*** *Structural Integrity Through Data-First Design*

*Problem*: FFmpeg filtergraphs are fragile string concatenations where a
single misplaced comma or bracket can cause cryptic failures.

*Solution*: Bioscoop represents filtergraphs as immutable data structures:

Instead of ~"scale=1920:1080,overlay"~, users write:

#+begin_src clojure
(chain (scale {:width 1920 :height 1080})
       (overlay))
#+end_src

*Benefits*:
- *Type safety*: Parameters are validated before execution
- *Immutability*: Filtergraphs can be safely composed and transformed

*** *Composable Architecture*

*Problem*: FFmpeg lacks native composition mechanisms, forcing
developers to manually manage complex filter concatenation.

*Solution*: Built-in composition protocol:

#+begin_src clojure
;; Seamless composition
(compose scale-graph overlay-graph crop-graph)
#+end_src

*Benefits*:
- *Modular design*: Complex pipelines built from simple components
- *Reusability*: Filtergraphs become first-class composable units
- *Testability*: Individual components can be tested in isolation

*** *Decoupled Label Management*

*Problem*: FFmpeg's label management is tightly coupled with
filtergraphs. Users have to manually label filtergraphs, it is
error-prone and difficult to debug.

*Solution*: Decoupling of labels and filtergraphs.

This is achieved internally by implementing labels as metadata on filters:

#+begin_src clojure
(-> (make-filter 'scale {:width 1920 :height 1080})
    (with-labels ["in"] ["out"]))
#+end_src

User-facing syntax stays close the FFmpeg convention: input labels at
the left of a filterchain, output labels at the right.

#+begin_src clojure
;; This is equivalent: "[in]scale=1920:1080[scaled]"
[["in"] (scale {:width 1920 :height 1080}) ["out"]]
#+end_src

However, because filtergraphs are first-class, we can now write:

#+begin_src clojure
(defgraph scaled (scale {:with 1920 :height 1080})) ;; first-class filtergraph, independent of labels

(bioscoop [["in"] scaled ["out"]]) ;; attach labels to filtergraph
#+end_src

*Benefits*:
- *Decoupling:* Labels and filtergraphs can be handled separately
- *Automatic label generation*: No more manual label tracking
- *Label validation*: Prevents duplicate or missing labels
- *Metadata preservation*: Labels persist through transformations

*** *Bidirectional Transformation*

*Problem*: FFmpeg filtergraphs are one-way - once created as strings,
they can't be easily analyzed or modified.

*Solution*: Round-trip transformation capabilities:

#+begin_src clojure
;; Parse FFmpeg string to data structure
(def parsed (ffmpeg/parse "scale=1920:1080,overlay"))

;; Modify the data structure
(def modified (update-in parsed [:chains 0 :filters] conj (crop {:width 800})))

;; Render back to FFmpeg string
(to-ffmpeg modified) ; => "scale=1920:1080,overlay,crop=width=800"
#+end_src

*Benefits*:
- *Analysis*: Programmatically inspect and analyze existing filtergraphs
- *Transformation*: Modify filtergraphs without string manipulation
- *Migration*: Update old filtergraph syntax to new patterns

*** Parameterization

In Ffmpeg, filters take parameters. This is what makes them flexible,
expressive and powerful. However, those parameters need to be
hard-coded in the filtergraph expression. Not so with bioscoop.

#+begin_src clojure
(defgraph transition (xfade {:transition "fade" :duration 1 :offset 9}))

(defn n-transition [n offset] (for [i (range n)]
                       (-> transition
                          (update-in [:chains 0 :filters 0 :args] assoc :bioscoop.domain.specs.effects/offset (+ i offset (* i offset)))
                          (update-in [:chains 0 :filters 0] with-labels [(if (zero? i) (str "out" i) (str "t" i)) (str "out" (inc i))] [(str "t" (inc i))]))))
#+end_src

*** Advanced Error Handling

*Problem*: FFmpeg provides cryptic error messages that are difficult to
trace back to specific filtergraph issues.

*Solution*: Structured error reporting with context:

#+begin_src clojure
(defprotocol ErrorHandling
  (accumulate-error [env value error-type]))
  
;; Detailed error information instead of "Invalid filter specification"
#+end_src

*Benefits*:
- *Precise error localization*: Know exactly which filter failed
- *Contextual information*: Error messages include surrounding filter context
- *Validation before execution*: Catch errors before invoking FFmpeg

*** *Spec-Driven Validation*

*Problem*: FFmpeg parameters are validated at runtime, often with
unclear error messages.

*Solution*: Pre-execution validation using Clojure spec:

#+begin_src clojure
(s/def ::width (s/and int? pos?))
(s/def ::height (s/and int? pos?))
(s/def ::scale-args (s/keys :req-un [::width ::height]))

;; Validation happens before FFmpeg execution
#+end_src

*Benefits*:
- *Early error detection*: Catch invalid parameters before FFmpeg runs
- *Clear error messages*: Know exactly which parameter failed validation
- *Documentation*: Specs serve as living documentation for filter parameters

** Gallery
:PROPERTIES:
:CUSTOM_ID: gallery
:END:

****** Cellular automata

[[file:gallery/cellauto.gif]]

FFmpeg syntax:

#+begin_src sh
"cellauto=rule=110:start_full=false:stitch=true:size=1024x1024[cell];[0:v]format=pix_fmts=yuva420p[img];[cell][img]overlay"
#+end_src

Bioscoop program:

#+begin_src clojure
(defgraph cellular (cellauto {:rule 110 :start_full false :stitch true :size "1024x1024"}))

(defgraph presentation (compose [cellular ["cell"]]
                                [["0:v" ] (format {:pix_fmts "yuva420p"}) ["img"]]
                                [["cell"] ["img"] (overlay)]))

(def filtergraph #(to-ffmpeg presentation))
#+end_src


****** Bitplanes

[[file:gallery/jumpinjackflash.gif]]

Ffmpeg syntax:

#+begin_src sh
"format=yuv420p10le|yuv422p10le|yuv444p10le|yuv440p10le,split=10[b0][b1][b2][b3][b4][b5][b6][b7][b8][b9];[b0]crop=iw/10:ih:(iw/10)*0:0,lutyuv=y=512:u=512:v=512:y=bitand(val\,pow(2\,10-1))*pow(2\,1)[b0c];[b1]crop=iw/10:ih:(iw/10)*1:0,lutyuv=y=512:u=512:v=512:y=bitand(val\,pow(2\,10-2))*pow(2\,2)[b1c];[b2]crop=iw/10:ih:(iw/10)*2:0,lutyuv=y=512:u=512:v=512:y=bitand(val\,pow(2\,10-3))*pow(2\,3)[b2c];[b3]crop=iw/10:ih:(iw/10)*3:0,lutyuv=y=512:u=512:v=512:y=bitand(val\,pow(2\,10-4))*pow(2\,4)[b3c];[b4]crop=iw/10:ih:(iw/10)*4:0,lutyuv=y=512:u=512:v=512:y=bitand(val\,pow(2\,10-5))*pow(2\,5)[b4c];[b5]crop=iw/10:ih:(iw/10)*5:0,lutyuv=y=512:u=512:v=512:y=bitand(val\,pow(2\,10-6))*pow(2\,6)[b5c];[b6]crop=iw/10:ih:(iw/10)*6:0,lutyuv=y=512:u=512:v=512:y=bitand(val\,pow(2\,10-7))*pow(2\,7)[b6c];[b7]crop=iw/10:ih:(iw/10)*7:0,lutyuv=y=512:u=512:v=512:y=bitand(val\,pow(2\,10-8))*pow(2\,8)[b7c]; [b8]crop=iw/10:ih:(iw/10)*8:0,lutyuv=y=512:u=512:v=512:y=bitand(val\,pow(2\,10-9))*pow(2\,9)[b8c];[b9]crop=iw/10:ih:(iw/10)*9:0,lutyuv=y=512:u=512:v=512:y=bitand(val\,pow(2\,10-10))*pow(2\,10)[b9c]; [b0c][b1c][b2c][b3c][b4c][b5c][b6c][b7c][b8c][b9c]hstack=10,format=yuv422p10le,drawgrid=w=iw/10:h=ih:t=2:c=cyan@1"
#+end_src

Bioscoop program:

#+begin_src clojure
(defgraph formatting (chain (format {:pix_fmts "yuv420p10le|yuv422p10le|yuv444p10le|yuv440p10le"})
                            (split {:outputs 10})))

(defgraph bitplane (chain (crop {:out_w "iw/10" :out_h "ih" :x "(iw/10)*0" :y "0"})
                          (lutyuv {:y "'bitand(val,pow(2,10-1))*pow(2,1)'" :u "512" :v "512"})))

(defgraph stacking (chain (hstack {:inputs 10})
                          (format {:pix_fmts "yuv422p10le"})
                          (drawgrid {:width "iw/10" :height "ih" :thickness "2" :color "cyan@1"})))

(defn n-formatting [n]
  (list (-> formatting
           (update-in [:chains 0 :filters 1] with-output-labels (into [] (for [i (range n)] (str "b" i)))))))

(defn n-stack [n]
  (list (-> stacking
           (update-in [:chains 0 :filters 0] with-input-labels (into [] (for [i (range n)] (str "b" i "c")))))))

(defn n-bitplane [n]
  (for [i (range n)]
    (-> bitplane
       (update-in [:chains 0 :filters 0 :args] assoc :bioscoop.domain.specs.crop/x (str "(iw/10)*" i))
       (update-in [:chains 0 :filters 1 :args] assoc :bioscoop.domain.specs.lut/y  (str "'bitand(val,pow(2,10-" (inc i) "))*pow(2," (inc i) ")'"))
       (update-in [:chains 0 :filters 0] with-input-labels [(str "b" i)])
       (update-in [:chains 0 :filters 1] with-output-labels [(str "b" i "c")]))))


(defn filtergraph [& {:keys [n] :or {n 10}}]
  (to-ffmpeg (apply compose-filtergraphs (concat (n-formatting n) (n-bitplane n) (n-stack n)))))
#+end_src

****** Lagfun

[[file:gallery/lagfun.gif]]

Ffmpeg syntax:

#+begin_src sh
"format=gbrp10[formatted];[formatted]split[a][b];[a]lagfun=decay=.99:planes=1[a];[b]lagfun=decay=.98:planes=2[b];[a][b]blend=all_mode=screen:c0_opacity=.5:c1_opacity=.5,format=yuv422p10le[out]"
#+end_src

Bioscoop program:

#+begin_src clojure
(defgraph formatting [(chain (format {:pix_fmts "gbrp10"})
                             (split {:outputs 2})) ["i0"] ["i1"]])

(defgraph fun (lagfun {:decay 0.99 :planes 1}))

(defn n-fun [n]
  (for [i (range n)]
    (-> fun
       (update-in [:chains 0 :filters 0 :args] assoc
                  :bioscoop.domain.specs.lagfun/decay (/ (- 99 i) 100)
                  :bioscoop.domain.specs.lagfun/planes (inc i))
       (update-in [:chains 0 :filters 0] with-labels [(str "i" i)] [(str "o" i )]))))

(defgraph blending [["o0"] ["o1"] (chain (blend {:all_mode "screen" :c0_opacity 0.5 :c1_opacity 0.6})
                                         (format {:pix_fmts "yuv422p10le"}))])

(defn filtergraph [] (to-ffmpeg (apply compose-filtergraphs `[~formatting
                                                              ~@(n-fun 2)
                                                              ~blending])))
#+end_src

******* Dance Me to the End of Love

A photography series entirely produced and presented with Bioscoop.

#+HTML <iframe width="560" height="315" src="https://www.youtube.com/embed/CWdZ3-Xh3vQ?si=_7A5EUHObvNdR1ii" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
