
[[file:resources/logo.svg]]

* A DSL for FFmpeg.

+ [[https://danielsz.github.io/bioscoop/][Documentation]].
+ Gallery

By replacing FFmpeg's notoriously complex and error-prone string-based
syntax with a structured, data-first approach, Bioscoop reifies
FFMpeg's filtergaph into a first-class, composable unit. This in turn
enables (dramatic) improvements in developer productivity, code
maintainability, and system reliability.

** Key Improvements Over Native FFmpeg Syntax

*** *Structural Integrity Through Data-First Design*

*Problem*: FFmpeg filtergraphs are fragile string concatenations where a
single misplaced comma or bracket can cause cryptic failures.

*Solution*: Bioscoop represents filtergraphs as immutable data structures:

Instead of ~"scale=1920:1080,overlay"~, users write:

#+begin_src clojure
(chain (scale {:width 1920 :height 1080})
       (overlay))
#+end_src

*Benefits*:
- *Type safety*: Parameters are validated before execution
- *Immutability*: Filtergraphs can be safely composed and transformed

*** *Composable Architecture*

*Problem*: FFmpeg lacks native composition mechanisms, forcing
developers to manually manage complex filter concatenation.

*Solution*: Built-in composition protocol:

#+begin_src clojure
;; Seamless composition
(compose scale-graph overlay-graph crop-graph)
#+end_src

*Benefits*:
- *Modular design*: Complex pipelines built from simple components
- *Reusability*: Filtergraphs become first-class composable units
- *Testability*: Individual components can be tested in isolation

*** *Decoupled Label Management*

*Problem*: FFmpeg's label management is tightly coupled with
filtergraphs. Users have to manually label filtergraphs, it is
error-prone and difficult to debug.

*Solution*: Decoupling of labels and filtergraphs.

This is achieved internally by implementing labels as metadata on filters:

#+begin_src clojure
(-> (make-filter 'scale {:width 1920 :height 1080})
    (with-labels ["in"] ["out"]))
#+end_src

User-facing syntax stays close the FFmpeg convention: input labels at
the left of a filterchain, output labels at the right.

#+begin_src clojure
;; This is equivalent: "[in]scale=1920:1080[scaled]"
[["in"] (scale {:width 1920 :height 1080}) ["out"]]
#+end_src

However, because filtergraphs are first-class, we can now write:

#+begin_src clojure
(defgraph scaled (scale {:with 1920 :height 1080})) ;; first-class filtergraph, independent of labels

(bioscoop [["in"] scaled ["out"]]) ;; attach labels to filtergraph
#+end_src

*Benefits*:
- *Decoupling:* Labels and filtergraphs can be handled separately
- *Automatic label generation*: No more manual label tracking
- *Label validation*: Prevents duplicate or missing labels
- *Metadata preservation*: Labels persist through transformations

*** *Bidirectional Transformation*

*Problem*: FFmpeg filtergraphs are one-way - once created as strings,
they can't be easily analyzed or modified.

*Solution*: Round-trip transformation capabilities:

#+begin_src clojure
;; Parse FFmpeg string to data structure
(def parsed (ffmpeg/parse "scale=1920:1080,overlay"))

;; Modify the data structure
(def modified (update-in parsed [:chains 0 :filters] conj (crop {:width 800})))

;; Render back to FFmpeg string
(to-ffmpeg modified) ; => "scale=1920:1080,overlay,crop=width=800"
#+end_src

*Benefits*:
- *Analysis*: Programmatically inspect and analyze existing filtergraphs
- *Transformation*: Modify filtergraphs without string manipulation
- *Migration*: Update old filtergraph syntax to new patterns

*** Parameterization

In Ffmpeg, filters take parameters. This is what makes them flexible,
expressive and powerful. However, those parameters need to be
hard-coded in the filtergraph expression. Not so with bioscoop.

#+begin_src clojure
(defgraph transition (xfade {:transition "fade" :duration 1 :offset 9}))

(defn n-transition [n offset] (for [i (range n)]
                       (-> transition
                          (update-in [:chains 0 :filters 0 :args] assoc :bioscoop.domain.specs.effects/offset (+ i offset (* i offset)))
                          (update-in [:chains 0 :filters 0] with-labels [(if (zero? i) (str "out" i) (str "t" i)) (str "out" (inc i))] [(str "t" (inc i))]))))
#+end_src

*** Advanced Error Handling

*Problem*: FFmpeg provides cryptic error messages that are difficult to
trace back to specific filtergraph issues.

*Solution*: Structured error reporting with context:

#+begin_src clojure
(defprotocol ErrorHandling
  (accumulate-error [env value error-type]))
  
;; Detailed error information instead of "Invalid filter specification"
#+end_src

*Benefits*:
- *Precise error localization*: Know exactly which filter failed
- *Contextual information*: Error messages include surrounding filter context
- *Validation before execution*: Catch errors before invoking FFmpeg

*** *Spec-Driven Validation*

*Problem*: FFmpeg parameters are validated at runtime, often with
unclear error messages.

*Solution*: Pre-execution validation using Clojure spec:

#+begin_src clojure
(s/def ::width (s/and int? pos?))
(s/def ::height (s/and int? pos?))
(s/def ::scale-args (s/keys :req-un [::width ::height]))

;; Validation happens before FFmpeg execution
#+end_src

*Benefits*:
- *Early error detection*: Catch invalid parameters before FFmpeg runs
- *Clear error messages*: Know exactly which parameter failed validation
- *Documentation*: Specs serve as living documentation for filter parameters


** Motivation 

Yes, FFmpeg is everywhere and it is amazing, but it is mainly used for
post-processing. Bioscoop is an attempt to unleash the power of FFmpeg
in the creative process. It offers an alternative to Non-Linear
editing of videos in favor of a programmatic approach.

FFmpeg offers a wealth of filters that can be
terseness, information density


FFmpeg has asserted its dominance in the post-processing phase of
video 
Unleash the power of FFmpeg in the creative process, beyond its
dominance in the post-processing 


[[[file:gallery/itsallaboutfilters.jpeg]]]


#+HTML: <img src="resources/itsallaboutfilters.jpeg" width="867" height="499"/>

It is a language-focused solution to the information density problem
of FFmpeg's filtergraph syntax.
It's not only that they are dense and terse, they lack
abstractions. They do not allow for composition, which is a key
principle when designing a system.


#+HTML: <video controls width="400"><source src="gallery/output.mp4" type="video/mp4/></video>

#+begin_src clojure

#+end_src

Told in the words of communties:

- Clojurians: a dsl that compiles Lisp forms to FFmpeg's filtergraph
- PLT: A context-free grammar describing a simple Lisp language -> AST transformation into data structues
-
  
[[file:gallery/output.gif]]

#+begin_src clojure
(defgraph cellular (cellauto {:rule 110 :start_full false :stitch true :size "1024x1024"}))

(defgraph presentation (compose [cellular ["cell"]]
                                [["0:v" ] (format {:pix_fmts "yuva420p"}) ["img"]]
                                [["cell"] ["img"] (overlay)]))
#+end_src
