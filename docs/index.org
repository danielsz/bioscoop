#+TITLE: Bioscoop
#+SUBTITLE: Creative coding with video
#+OPTIONS: toc:1 num:nil
#+HTML_HEAD: <link rel="stylesheet" href="css/et-book.css" type="text/css" media="screen" />
#+HTML_HEAD: <link href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:300,300i,400,600&display=swap" rel="stylesheet">
#+HTML_HEAD: <link rel="stylesheet" href="css/main.css" type="text/css" media="screen" />
#+HTML_HEAD: <link rel="stylesheet" href="css/post.css" type="text/css" media="screen" />
#+HTML_HEAD:  <script type="text/javascript" src="js/navigation.js"></script>

* Motivation

Historically, video editing has progressed from destructive
techniques, ie. cutting the negative, to non-destructive ones,
ie. non-linear editing. The latter has become possible due to film
being no longer analog but digital. In both cases, however, the
creative process is manual, or mouse-based. A different approach,
often overlooked, is programmatic: the editor spells out the edits he
wants to apply, and those are being carried out by an underlying
system.  FFmpeg is such a system; capable of carrying pretty much any
editing instruction you can think of.

FFmpeg is embedded in virtually every major platform and application
that handles media, yet its use in the creative coding community to
make video art is limited. Most video creators prefer to stay away
from the notoriously complex and error-prone string-based
syntax. Indeed, its usability is hindered by the information density
of its textual interface.

Bioscoop unleashes FFmpeg from its shackles and puts programmability
in the center of the creative process.

* Internals

** Bioscoop: FFmpeg Filtergraph DSL

*Bioscoop* is a Clojure library that provides a domain-specific language
(DSL) for building FFmpeg filtergraphs. It allows you to write
video/audio filter operations in a Lisp-like syntax that compiles down
to FFmpeg's native filtergraph format.

*** Core Architecture

The project is structured around several key components:

**** 1. *DSL Parser (=src/bioscoop/dsl.clj=)*
- Uses *Instaparse* to parse a Lisp-like syntax defined in =resources/lisp-grammar.bnf=
- Supports typical Lisp constructs: functions, let bindings, symbols, keywords, strings, numbers, booleans
- Grammar allows for expressions like =(scale 1920 1080)= and =(let [width 1920] (scale width 1080))=

**** 2. *Domain Model (=src/bioscoop/domain/records.clj=)*
- Uses Clojure Spec to define the structure of filters, filter chains, and filtergraphs
- Provides validation for the core data structures

**** 3. *Core Data Structures*
Three main records represent FFmpeg concepts:
- *=Filter=*: A single filter operation (e.g., scale, overlay, crop)
- *=FilterChain=*: A sequence of filters connected in series (comma-separated in FFmpeg)
- *=FilterGraph=*: Multiple filter chains running in parallel (semicolon-separated in FFmpeg)

**** 4. *Rendering Engine (=src/bioscoop/render.clj=)*
- Implements the =FFmpegRenderable= protocol to convert data structures to FFmpeg syntax
- Handles input/output labels for complex filtergraphs 
- Ensures proper escaping and formatting

**** 5. /Bidirectional Translation/
- /=src/bioscoop/render.clj=*: Converts DSL → FFmpeg filtergraph strings
- /=src/bioscoop/ffmpeg.clj=*: Parses existing FFmpeg filtergraph strings → DSL structures



* The filtergraph

In FFmpeg, atomic editing tasks like scaling, cropping, blending,
coloring, etc. are captured in filters. FFmpeg has more than 500 of
them. When applying filters in sequence on source material, filters
are being written in sequence, separated by a coma. Those are called
filterchains. Filterchains can be labeled at both ends, so that their
output can serve as input to another filterchain. Filterchains form a
structure known as a directed acyclic graph (DAG), and FFmpeg calls it
a filtergraph. Filtergraphs are being passed to FFmpeg in the
~-filter_complex~ parameter.


* Inspiration

#+begin_quote
The acts of the mind, wherein it exerts its power over simple ideas, are chiefly these three:

1. Combining several simple ideas into one compound one, and thus all
   complex ideas are made.

2. The second is bringing two ideas, whether simple or complex,
   together, and setting them by one another so as to take a view of
   them at once, without uniting them into one, by which it gets all
   its ideas of relations.

3. The third is separating them from all other ideas that accompany
   them in their real existence: this is called abstraction, and thus
   all its general ideas are made.

—John Locke, An Essay Concerning Human Understanding (1690)
#+end_quote


