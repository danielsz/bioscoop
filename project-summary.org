** Bioscoop: FFmpeg Filtergraph DSL

*Bioscoop* is a Clojure library that provides a domain-specific language (DSL) for building FFmpeg filtergraphs. It allows you to write video/audio filter operations in a Lisp-like syntax that compiles down to FFmpeg's native filtergraph format.

*** Core Architecture

The project is structured around several key components:

**** 1. *DSL Parser (=src/bioscoop/dsl.clj=)*
- Uses *Instaparse* to parse a Lisp-like syntax defined in =resources/lisp-grammar.bnf=
- Supports typical Lisp constructs: functions, let bindings, symbols, keywords, strings, numbers, booleans
- Grammar allows for expressions like =(scale 1920 1080)= and =(let [width 1920] (scale width 1080))=

**** 2. *Domain Model (=src/bioscoop/domain/filtergraph.clj=)*
- Uses Clojure Spec to define the structure of filters, filter chains, and filtergraphs
- Provides validation for the core data structures

**** 3. *Core Data Structures*
Three main records represent FFmpeg concepts:
- *=Filter=*: A single filter operation (e.g., scale, overlay, crop)
- *=FilterChain=*: A sequence of filters connected in series (comma-separated in FFmpeg)
- *=FilterGraph=*: Multiple filter chains running in parallel (semicolon-separated in FFmpeg)

**** 4. *Rendering Engine (=src/bioscoop/render.clj=)*
- Implements the =FFmpegRenderable= protocol to convert data structures to FFmpeg syntax
- Handles input/output labels for complex filtergraphs 
- Ensures proper escaping and formatting

** 5. /Bidirectional Translation/
- /=src/bioscoop/render.clj=*: Converts DSL → FFmpeg filtergraph strings
- /=src/bioscoop/ffmpeg.clj=*: Parses existing FFmpeg filtergraph strings → DSL structures

*/ Example Usage

From the tests, here's how the DSL works:

#+begin_src clojure
;; Simple filter: scale video to 1920x1080
(scale 1920 1080)
;; Renders to: "scale=1920:1080"

;; With let bindings for reusable values
(let [width 1920 height 1080]
  (scale width height))

;; Complex filtergraph with multiple chains
[(scale 1920 1080) 
 (overlay 10 10)]
;; Creates parallel filter chains

;; Function definitions for reusable components
(def standard-scale (fn [w h] (scale w h)))
#+end_src

*/ Key Features

1. /Type Safety/: Uses Clojure Spec for validation
2. /Composability/: Filters can be combined into chains and graphs
3. /Reusability/: Support for function definitions and let bindings
4. /Bidirectional/: Can both generate and parse FFmpeg filtergraphs
5. /Extensible/: Easy to add new filter types

*/ Data-First Design

Following Clojure's philosophy, the library prioritizes data structures:
- Filters are represented as simple maps with =:name= and =:arguments=
- Filter chains are vectors of filters
- Filter graphs are vectors of filter chains
- The DSL provides a more ergonomic syntax that compiles to these structures

*/ Use Cases

This DSL would be particularly useful for:
- Video processing pipelines where filtergraphs need to be generated programmatically
- Template-based video generation
- Complex filter operations that benefit from Clojure's functional composition
- Applications that need to both generate and parse FFmpeg filter strings

The project demonstrates excellent Clojure design principles: immutable data structures, clear separation of parsing/rendering concerns, comprehensive testing, and a data-first approach to domain modeling.

*** Produces valid FFmpeg filtergraph strings

**** *FFmpeg Parser (=src/bioscoop/ffmpeg_parser.clj=)*
- Can parse existing FFmpeg filtergraph strings back into the internal data structures
- Provides bidirectional conversion (DSL ↔ FFmpeg string)

*** DSL Features

**** Basic Filter Creation
#+begin_src clojure
;; Named function approach
(scale 1920 1080)          ; → "scale=1920:1080"

;; Generic filter approach  
(filter "scale" "1920:1080") ; → "scale=1920:1080"
#+end_src

**** Filter Chains
#+begin_src clojure
(chain (scale 1920 1080) (overlay)) ; → "scale=1920:1080,overlay"
#+end_src

**** Let Bindings for Variables
#+begin_src clojure
(let [width 1920 
      height 1080] 
  (scale width height))     ; → "scale=1920:1080"
#+end_src

**** Input/Output Labels
#+begin_src clojure
(let [input-vid (input-labels "in")
      scaled (filter "scale" "1920:1080" input-vid (output-labels "scaled"))]
  scaled)                   ; → "[in]scale=1920:1080[scaled]"
#+end_src

**** Built-in Filter Functions
The DSL includes predefined functions for common filters:
- =scale=, =crop=, =overlay=, =fade=
- Arithmetic operators: =+=, =-=, =*=, =/=
- Utility functions: =str=
  
*** Key Dependencies

- *Instaparse*: For parsing the DSL grammar
- *FFmpeg Java wrapper*: For integration with FFmpeg
- *Clojure Spec*: For data validation
- *Logback*: For logging

*** Usage Flow

1. *Write DSL code* in the Lisp-like syntax
2. *Parse* using the grammar defined in =lisp-grammar.bnf=
3. *Transform* the AST into Filter/FilterChain/FilterGraph records
4. *Render* to FFmpeg filtergraph strings
5. *Execute* with FFmpeg

*** Example End-to-End

#+begin_src clojure
;; DSL Input
"(chain (scale 1920 1080) (overlay))"

;; Parsed & Compiled to
FilterGraph{
  :chains [FilterChain{
    :filters [Filter{:name "scale", :args "1920:1080"}
              Filter{:name "overlay", :args nil}]}]}

;; Rendered to FFmpeg
"scale=1920:1080,overlay"
#+end_src

This architecture provides a clean separation between the high-level DSL, the internal representation, and the low-level FFmpeg syntax, making it easier to build complex video processing pipelines programmatically.
